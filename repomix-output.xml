This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
.repomixignore
backend/.env
backend/.gitignore
backend/alembic.ini
backend/alembic/env.py
backend/alembic/script.py.mako
backend/alembic/versions/a1b2c3d4e5f6_add_category_and_business_features.py
backend/alembic/versions/b931ba38f663_initial_migration_with_poi_models.py
backend/app/api/endpoints/categories.py
backend/app/api/endpoints/pois.py
backend/app/core/config.py
backend/app/crud/__init__.py
backend/app/crud/crud_category.py
backend/app/crud/crud_poi.py
backend/app/database.py
backend/app/main.py
backend/app/models/__init__.py
backend/app/models/category.py
backend/app/models/poi.py
backend/app/schemas/__init__.py
backend/app/schemas/category.py
backend/app/schemas/poi.py
backend/Dockerfile
backend/requirements.txt
backend/tests/conftest.py
backend/tests/test_pois_api.py
docker-compose.yml
file_populator.py
frontend/.eslintrc.cjs
frontend/.gitignore
frontend/Dockerfile
frontend/index.html
frontend/nginx.conf
frontend/package.json
frontend/public/vite.svg
frontend/src/animations.css
frontend/src/App.jsx
frontend/src/components/CategoryForm.jsx
frontend/src/components/CategoryList.jsx
frontend/src/components/CategorySelector.jsx
frontend/src/components/POIForm.jsx
frontend/src/components/POIList.jsx
frontend/src/components/POIMap.jsx
frontend/src/main.jsx
frontend/vite.config.js
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.gitignore">
__pycache__/
</file>

<file path="backend/alembic/versions/a1b2c3d4e5f6_add_category_and_business_features.py">
"""Add category and business features

Revision ID: a1b2c3d4e5f6
Revises: b931ba38f663
Create Date: 2025-06-15 10:30:00.123456

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = 'a1b2c3d4e5f6'
down_revision = 'b931ba38f663'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('categories',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('slug', sa.String(), nullable=False),
    sa.Column('parent_id', sa.UUID(), nullable=True),
    sa.ForeignKeyConstraint(['parent_id'], ['categories.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name'),
    sa.UniqueConstraint('slug')
    )
    op.create_index(op.f('ix_categories_slug'), 'categories', ['slug'], unique=True)
    op.add_column('businesses', sa.Column('listing_type', sa.String(), nullable=False, server_default='free'))
    op.add_column('businesses', sa.Column('attributes', postgresql.JSONB(astext_type=sa.Text()), nullable=True))
    op.create_table('poi_category_association',
    sa.Column('poi_id', sa.UUID(), nullable=False),
    sa.Column('category_id', sa.UUID(), nullable=False),
    sa.ForeignKeyConstraint(['category_id'], ['categories.id'], ),
    sa.ForeignKeyConstraint(['poi_id'], ['points_of_interest.id'], ),
    sa.PrimaryKeyConstraint('poi_id', 'category_id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('poi_category_association')
    op.drop_column('businesses', 'attributes')
    op.drop_column('businesses', 'listing_type')
    op.drop_index(op.f('ix_categories_slug'), table_name='categories')
    op.drop_table('categories')
    # ### end Alembic commands ###
</file>

<file path="backend/app/api/endpoints/categories.py">
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app import crud, schemas
from app.database import get_db

router = APIRouter()

@router.post("/", response_model=schemas.Category, status_code=201)
def create_category(category: schemas.CategoryCreate, db: Session = Depends(get_db)):
    # Simple logic to prevent duplicate slugs could be added here if needed
    return crud.create_category(db=db, category=category)

@router.get("/tree", response_model=List[schemas.CategoryWithChildren])
def read_category_tree(db: Session = Depends(get_db)):
    """
    Returns all categories in a nested tree structure.
    """
    return crud.get_all_categories_as_tree(db=db)
</file>

<file path="backend/app/crud/crud_category.py">
from sqlalchemy.orm import Session
from fastapi import HTTPException
from typing import List, Dict

from app import models, schemas

def get_all_categories(db: Session) -> List[models.Category]:
    return db.query(models.Category).order_by(models.Category.name).all()

def get_category(db: Session, category_id: str) -> models.Category:
    return db.query(models.Category).filter(models.Category.id == category_id).first()

def create_category(db: Session, category: schemas.CategoryCreate) -> models.Category:
    db_category = models.Category(
        name=category.name,
        slug=category.slug,
        parent_id=category.parent_id
    )
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category

def get_all_categories_as_tree(db: Session) -> List[schemas.CategoryWithChildren]:
    """
    Fetches all categories and organizes them into a parent-child tree structure.
    """
    all_categories = get_all_categories(db)
    category_map: Dict[str, schemas.CategoryWithChildren] = {
        str(cat.id): schemas.CategoryWithChildren.model_validate(cat) for cat in all_categories
    }
    
    tree: List[schemas.CategoryWithChildren] = []
    
    for cat_id, category in category_map.items():
        if category.parent_id and str(category.parent_id) in category_map:
            parent = category_map[str(category.parent_id)]
            parent.children.append(category)
        else:
            tree.append(category)
            
    return tree
</file>

<file path="backend/app/models/category.py">
import uuid
from sqlalchemy import Column, String, ForeignKey, Table
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship

from app.database import Base

# Association Table for the many-to-many relationship between POIs and Categories
poi_category_association = Table('poi_category_association', Base.metadata,
    Column('poi_id', UUID(as_uuid=True), ForeignKey('points_of_interest.id'), primary_key=True),
    Column('category_id', UUID(as_uuid=True), ForeignKey('categories.id'), primary_key=True)
)

class Category(Base):
    __tablename__ = "categories"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False, unique=True)
    slug = Column(String, nullable=False, unique=True, index=True)
    
    # For self-referencing hierarchy (subcategories)
    parent_id = Column(UUID(as_uuid=True), ForeignKey("categories.id"), nullable=True)
    
    # Relationship to parent category
    parent = relationship("Category", remote_side=[id], backref="children")

    # This relationship is defined in the PointOfInterest model via back_populates
    # pois = relationship("PointOfInterest", secondary=poi_category_association, back_populates="categories")
</file>

<file path="backend/app/schemas/category.py">
import uuid
from typing import List, Optional
from pydantic import BaseModel, model_validator
import re

# Helper for slug generation (can be shared)
def generate_slug(value: str) -> str:
    s = value.lower().strip()
    s = re.sub(r'[^\w\s-]', '', s)
    s = re.sub(r'[\s_-]+', '-', s)
    s = re.sub(r'^-+|-+$', '', s)
    return s

class CategoryBase(BaseModel):
    name: str
    parent_id: Optional[uuid.UUID] = None

class CategoryCreate(CategoryBase):
    slug: Optional[str] = None

    @model_validator(mode='before')
    @classmethod
    def generate_slug_from_name(cls, values):
        if isinstance(values, dict):
             if not values.get('slug') and values.get('name'):
                values['slug'] = generate_slug(values['name'])
        return values

class Category(CategoryBase):
    id: uuid.UUID
    slug: str

    class Config:
        from_attributes = True

# Recursive schema for nested display
class CategoryWithChildren(Category):
    children: List['CategoryWithChildren'] = []
</file>

<file path="frontend/src/components/CategoryForm.jsx">
import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useForm } from '@mantine/form';
import { TextInput, Button, Group, Box, Title, Select, Paper } from '@mantine/core';
import axios from 'axios';
import { notifications } from '@mantine/notifications';

const API_URL = import.meta.env.VITE_API_BASE_URL;

function CategoryForm() {
  const { id } = useParams();
  const navigate = useNavigate();
  const isEditing = Boolean(id);
  const [categories, setCategories] = useState([]);

  const form = useForm({
    initialValues: {
      name: '',
      parent_id: null,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'Name must have at least 2 characters' : null),
    },
  });

  useEffect(() => {
    // Fetch all categories to populate the 'parent' dropdown
    const fetchCategories = async () => {
        try {
            const response = await axios.get(`${API_URL}/api/categories/tree`);
            const flattened = [];
            const flatten = (cats, depth = 0) => {
                cats.forEach(cat => {
                    flattened.push({ value: cat.id, label: `${'— '.repeat(depth)}${cat.name}` });
                    if (cat.children) flatten(cat.children, depth + 1);
                });
            };
            flatten(response.data);
            setCategories(flattened);
        } catch (error) {
            notifications.show({ title: 'Error', message: 'Could not fetch categories for parent selection.', color: 'red' });
        }
    };
    fetchCategories();

    if (isEditing) {
      // Fetch data for the specific category being edited
      // Note: A GET /api/categories/{id} endpoint would be needed on the backend
      // For now, we'll assume we can't edit.
    }
  }, [id, isEditing]);

  const handleSubmit = async (values) => {
    const payload = {
        name: values.name,
        parent_id: values.parent_id || null, // Ensure null is sent if empty
    };

    try {
      await axios.post(`${API_URL}/api/categories/`, payload);
      notifications.show({ title: 'Success!', message: `Category "${values.name}" created!`, color: 'green' });
      navigate('/categories'); // Go back to the category list
    } catch (error) {
      notifications.show({ title: 'Error', message: 'Failed to create category.', color: 'red' });
    }
  };

  return (
    <Paper maw={600} mx="auto">
      <Title order={2} c="deep-purple.7" mb="xl">
        {isEditing ? 'Edit Category' : 'Create New Category'}
      </Title>
      <form onSubmit={form.onSubmit(handleSubmit)}>
        <TextInput withAsterisk label="Category Name" placeholder="e.g., Food & Drinks" {...form.getInputProps('name')} />
        <Select
          label="Parent Category (Optional)"
          placeholder="Select a parent to make this a subcategory"
          data={categories}
          {...form.getInputProps('parent_id')}
          mt="md"
          clearable
          searchable
        />
        <Group justify="flex-end" mt="xl">
          <Button variant="default" onClick={() => navigate('/categories')}>Cancel</Button>
          <Button type="submit">
            {isEditing ? 'Update Category' : 'Create Category'}
          </Button>
        </Group>
      </form>
    </Paper>
  );
}

export default CategoryForm;
</file>

<file path="frontend/src/components/CategoryList.jsx">
import { useState, useEffect } from 'react';
import axios from 'axios';
import { Table, Button, Group, Title, Paper, ActionIcon, Tooltip, Text } from '@mantine/core';
import { useNavigate } from 'react-router-dom';
import { notifications } from '@mantine/notifications';
import { IconPencil, IconTrash, IconPlus } from '@tabler/icons-react';

const API_URL = import.meta.env.VITE_API_BASE_URL;

function CategoryList() {
  const [categories, setCategories] = useState([]);
  const navigate = useNavigate();

  const fetchCategories = async () => {
    try {
      // We will fetch a flat list for management
      const response = await axios.get(`${API_URL}/api/categories/tree`); // Using tree to get hierarchy info
      
      // Flatten the tree for table display
      const flattened = [];
      const flatten = (cats, depth = 0) => {
        cats.forEach(cat => {
            flattened.push({ ...cat, depth });
            if (cat.children) {
                flatten(cat.children, depth + 1);
            }
        });
      };
      flatten(response.data);
      setCategories(flattened);

    } catch (error) {
      notifications.show({
        title: 'Error fetching data',
        message: 'Could not load categories.',
        color: 'red',
      });
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  const handleDelete = async (categoryId) => {
    if (window.confirm('Are you sure you want to delete this category? This might affect existing POIs.')) {
      // Note: A real delete endpoint would need to be added to the backend.
      notifications.show({ title: 'Info', message: 'Delete functionality not yet implemented on backend.', color: 'blue' });
    }
  };

  const rows = categories.map((category) => (
    <Table.Tr key={category.id}>
      <Table.Td>
        <Text pl={category.depth * 20}>
            {'— '.repeat(category.depth)} {category.name}
        </Text>
      </Table.Td>
      <Table.Td>
        <Group gap="xs" justify="flex-end">
          <Tooltip label="Edit Category">
            <ActionIcon variant="subtle" color="gray" onClick={() => navigate(`/category/${category.id}/edit`)}>
              <IconPencil size={18} />
            </ActionIcon>
          </Tooltip>
          <Tooltip label="Delete Category">
            <ActionIcon variant="subtle" color="red" onClick={() => handleDelete(category.id)}>
              <IconTrash size={18} />
            </ActionIcon>
          </Tooltip>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <Paper>
      <Group justify="space-between" mb="lg">
        <Title order={2} c="deep-purple.7">Manage Categories</Title>
        <Button onClick={() => navigate('/category/new')} leftSection={<IconPlus size={18} />}>
            Create New Category
        </Button>
      </Group>
      <Table striped highlightOnHover withTableBorder>
        <Table.Thead>
          <Table.Tr>
            <Table.Th>Name</Table.Th>
            <Table.Th style={{ textAlign: 'right' }}>Actions</Table.Th>
          </Table.Tr>
        </Table.Thead>
        <Table.Tbody>{rows}</Table.Tbody>
      </Table>
    </Paper>
  );
}

export default CategoryList;
</file>

<file path="frontend/src/components/CategorySelector.jsx">
import { useState, useEffect } from 'react';
import { Box, Checkbox, Group, Text, Pill, ScrollArea, TextInput, ActionIcon, Collapse, Stack, Loader } from '@mantine/core';
import { IconSearch, IconChevronRight } from '@tabler/icons-react';
import axios from 'axios';
import { notifications } from '@mantine/notifications';

const API_URL = import.meta.env.VITE_API_BASE_URL;

// This is a recursive component to render categories and their children
function CategoryTree({ categories, selected, onToggle, searchTerm, parentIsOpened = false }) {
  const [opened, setOpened] = useState({});

  const handleToggleCollapse = (id) => {
    setOpened(prev => ({ ...prev, [id]: !prev[id] }));
  };

  // Filter categories based on search term
  const filteredCategories = categories.filter(cat => {
    const nameMatch = cat.name.toLowerCase().includes(searchTerm.toLowerCase());
    const childMatch = cat.children && cat.children.some(child => 
      child.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    return nameMatch || childMatch;
  });

  return (
    <Stack gap="xs">
      {filteredCategories.map(category => {
        const isOpened = opened[category.id] || (searchTerm.length > 0);
        return (
          <Box key={category.id}>
            <Group wrap="nowrap">
              {category.children && category.children.length > 0 && (
                <ActionIcon onClick={() => handleToggleCollapse(category.id)} size="sm" variant="transparent">
                  <IconChevronRight size={14} style={{ transform: isOpened ? 'rotate(90deg)' : 'none', transition: 'transform 0.2s' }} />
                </ActionIcon>
              )}
              <Checkbox
                label={category.name}
                checked={selected.includes(category.id)}
                onChange={() => onToggle(category.id, category)}
              />
            </Group>
            {category.children && category.children.length > 0 && (
              <Collapse in={isOpened}>
                <Box pl="xl" pt="xs">
                  {/* Recursive call for subcategories */}
                  <CategoryTree 
                    categories={category.children} 
                    selected={selected} 
                    onToggle={onToggle} 
                    searchTerm={searchTerm}
                    parentIsOpened={isOpened}
                  />
                </Box>
              </Collapse>
            )}
          </Box>
        );
      })}
    </Stack>
  );
}

export function CategorySelector({ value, onChange }) {
  const [allCategories, setAllCategories] = useState([]);
  const [categoryMap, setCategoryMap] = useState({});
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const { data } = await axios.get(`${API_URL}/api/categories/tree`);
        setAllCategories(data);

        const map = {};
        const flatten = (cats) => {
          cats.forEach(c => {
            map[c.id] = c.name;
            if (c.children) flatten(c.children);
          });
        };
        flatten(data);
        setCategoryMap(map);
      } catch (error) {
        notifications.show({
          title: 'Error',
          message: 'Failed to fetch categories.',
          color: 'red',
        });
      } finally {
        setLoading(false);
      }
    };
    fetchCategories();
  }, []);

  const handleToggle = (id) => {
    const newSelection = value.includes(id) ? value.filter(v => v !== id) : [...value, id];
    onChange(newSelection);
  };

  const selectedPills = value
    .map(id => ({ id, name: categoryMap[id] }))
    .filter(cat => cat.name) // Filter out any IDs that might not have a name yet
    .map(cat => (
      <Pill key={cat.id} withRemoveButton onRemove={() => handleToggle(cat.id)}>
        {cat.name}
      </Pill>
    ));

  return (
    <div>
      <TextInput
        placeholder="Search for categories..."
        leftSection={<IconSearch size={16} />}
        value={searchTerm}
        onChange={(event) => setSearchTerm(event.currentTarget.value)}
        mb="md"
      />
      <Text size="sm" fw={500} mb={selectedPills.length > 0 ? 'xs' : 0}>Selected:</Text>
      <Group mb="md" gap="xs">
        {selectedPills.length > 0 ? selectedPills : <Text size="sm" c="dimmed">None</Text>}
      </Group>
      <ScrollArea h={300} style={{ border: '1px solid var(--mantine-color-gray-3)', borderRadius: 'var(--mantine-radius-md)' }} p="sm">
        {loading ? (
            <Group justify="center" pt="xl"><Loader /></Group>
        ) : (
            <CategoryTree categories={allCategories} selected={value} onToggle={handleToggle} searchTerm={searchTerm} />
        )}
      </ScrollArea>
    </div>
  );
}
</file>

<file path=".gitignore">
node_modules/
</file>

<file path=".repomixignore">
repomix-output.xml
files.txt
</file>

<file path="backend/.env">
DATABASE_URL=postgresql://nearby:nearby@localhost:5432/nearbynearby
</file>

<file path="backend/alembic.ini">
[alembic]
script_location = alembic
sqlalchemy.url = driver://user:pass@localhost/dbname

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="backend/alembic/env.py">
import os
import sys
from logging.config import fileConfig

# FIX: Add the project root directory to the Python path
# This ensures that Alembic can find the 'app' module
sys.path.insert(0, os.path.realpath(os.path.join(os.path.dirname(__file__), '..')))

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

from dotenv import load_dotenv

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Load environment variables from .env file
load_dotenv()

# Import your models' Base
from app.database import Base
from app.models import poi # Import all your models here

# Set the target metadata for autogenerate
target_metadata = Base.metadata

def get_url():
    return os.getenv("DATABASE_URL")

# FIX: Add this function to ignore tables that are not part of our models
# This prevents Alembic from trying to drop PostGIS's internal tables.
def include_object(object, name, type_, reflected, compare_to):
    if type_ == "table" and name not in target_metadata.tables:
        return False
    return True

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = get_url()
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        # Add the include_object function here for offline mode
        include_object=include_object,
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    ini_config = config.get_section(config.config_ini_section)
    ini_config['sqlalchemy.url'] = get_url()
    
    connectable = engine_from_config(
        ini_config,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, 
            target_metadata=target_metadata,
            # Add the include_object function here for online mode
            include_object=include_object,
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="backend/alembic/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
</file>

<file path="backend/alembic/versions/b931ba38f663_initial_migration_with_poi_models.py">
"""Initial migration with POI models

Revision ID: b931ba38f663
Revises: 
Create Date: 2025-06-14 15:45:18.426467

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
import geoalchemy2

# revision identifiers, used by Alembic.
revision = 'b931ba38f663'
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('locations',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('address_line1', sa.String(), nullable=True),
    sa.Column('city', sa.String(), nullable=True),
    sa.Column('state_abbr', sa.String(length=2), nullable=True),
    sa.Column('postal_code', sa.String(), nullable=True),
    sa.Column('coordinates', geoalchemy2.types.Geometry(geometry_type='POINT', srid=4326, from_text='ST_GeomFromEWKT', name='geometry', nullable=False), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    # FIX: Removed the redundant index creation. op.create_table handles this automatically for Geometry columns.
    # op.create_index('idx_locations_coordinates', 'locations', ['coordinates'], unique=False, postgresql_using='gist')
    op.create_table('points_of_interest',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('slug', sa.String(), nullable=False),
    sa.Column('description', sa.Text(), nullable=True),
    sa.Column('poi_type', sa.String(), nullable=False),
    sa.Column('status', sa.String(), nullable=False),
    sa.Column('location_id', sa.UUID(), nullable=True),
    sa.ForeignKeyConstraint(['location_id'], ['locations.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_points_of_interest_slug'), 'points_of_interest', ['slug'], unique=True)
    op.create_table('businesses',
    sa.Column('poi_id', sa.UUID(), nullable=False),
    sa.Column('price_range', sa.String(), nullable=True),
    sa.Column('amenities', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.ForeignKeyConstraint(['poi_id'], ['points_of_interest.id'], ),
    sa.PrimaryKeyConstraint('poi_id')
    )
    op.create_table('events',
    sa.Column('poi_id', sa.UUID(), nullable=False),
    sa.Column('start_datetime', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('end_datetime', sa.TIMESTAMP(timezone=True), nullable=True),
    sa.Column('venue_poi_id', sa.UUID(), nullable=True),
    sa.ForeignKeyConstraint(['poi_id'], ['points_of_interest.id'], ),
    sa.ForeignKeyConstraint(['venue_poi_id'], ['points_of_interest.id'], ),
    sa.PrimaryKeyConstraint('poi_id')
    )
    op.create_table('outdoors',
    sa.Column('poi_id', sa.UUID(), nullable=False),
    sa.Column('outdoor_specific_type', sa.String(), nullable=True),
    sa.Column('facilities', postgresql.JSONB(astext_type=sa.Text()), nullable=True),
    sa.Column('trail_length_km', sa.Numeric(precision=6, scale=2), nullable=True),
    sa.ForeignKeyConstraint(['poi_id'], ['points_of_interest.id'], ),
    sa.PrimaryKeyConstraint('poi_id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('outdoors')
    op.drop_table('events')
    op.drop_table('businesses')
    op.drop_index(op.f('ix_points_of_interest_slug'), table_name='points_of_interest')
    op.drop_table('points_of_interest')
    # Since the index is created implicitly with the table, it should also be dropped implicitly.
    # No explicit op.drop_index is needed here for 'idx_locations_coordinates'.
    op.drop_table('locations')
    # ### end Alembic commands ###
</file>

<file path="backend/app/api/endpoints/pois.py">
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
import uuid

# The __init__.py files now allow these cleaner imports
from app import crud, schemas
from app.database import get_db

router = APIRouter()

@router.post("/pois/", response_model=schemas.PointOfInterest, status_code=201)
def create_poi(poi: schemas.PointOfInterestCreate, db: Session = Depends(get_db)):
    # Simple check to ensure subtype data matches poi_type
    if poi.poi_type == 'business' and not poi.business:
        raise HTTPException(status_code=400, detail="Business data required for poi_type 'business'")
    if poi.poi_type == 'outdoors' and not poi.outdoors:
        raise HTTPException(status_code=400, detail="Outdoors data required for poi_type 'outdoors'")
    if poi.poi_type == 'event' and not poi.event:
        raise HTTPException(status_code=400, detail="Event data required for poi_type 'event'")

    # Notice the call is now simpler: crud.create_poi instead of crud.crud_poi.create_poi
    return crud.create_poi(db=db, poi=poi)


@router.get("/pois/", response_model=List[schemas.PointOfInterest])
def read_pois(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    pois = crud.get_pois(db, skip=skip, limit=limit)
    return pois


@router.get("/pois/{poi_id}", response_model=schemas.PointOfInterest)
def read_poi(poi_id: uuid.UUID, db: Session = Depends(get_db)):
    db_poi = crud.get_poi(db, poi_id=poi_id)
    if db_poi is None:
        raise HTTPException(status_code=404, detail="Point of Interest not found")
    return db_poi

# Note: A full PUT/PATCH implementation would be more complex, handling partial updates
# and changes of POI type. For this MVP, we focus on Create, Read, Delete.
# A basic PUT could be added here if necessary.

@router.delete("/pois/{poi_id}", response_model=schemas.PointOfInterest)
def delete_poi(poi_id: uuid.UUID, db: Session = Depends(get_db)):
    db_poi = crud.delete_poi(db, poi_id=poi_id)
    if db_poi is None:
        raise HTTPException(status_code=404, detail="Point of Interest not found")
    return db_poi
</file>

<file path="backend/app/core/config.py">
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Provide a default value for safety, though it will be overridden by docker-compose
    DATABASE_URL: str = "postgresql://user:pass@localhost/db"

    class Config:
        env_file = ".env"

settings = Settings()
</file>

<file path="backend/app/crud/__init__.py">
# This file makes it possible to import CRUD functions like:
# from app.crud import create_poi
# instead of the more verbose:
# from app.crud.crud_poi import create_poi

from .crud_poi import get_poi, get_pois, create_poi, delete_poi
# FIX: Add the new category crud functions to the package's namespace
from .crud_category import get_category, create_category, get_all_categories, get_all_categories_as_tree
</file>

<file path="backend/app/crud/crud_poi.py">
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError
from fastapi import HTTPException
import uuid

# Changed this import to be more explicit
from app import models, schemas
# FIX: Import the specific function needed to avoid circular dependencies
from app.crud.crud_category import get_category

def get_poi(db: Session, poi_id: uuid.UUID):
    return db.query(models.PointOfInterest).options(
        joinedload(models.PointOfInterest.location),
        joinedload(models.PointOfInterest.business),
        joinedload(models.PointOfInterest.outdoors),
        joinedload(models.PointOfInterest.event),
        joinedload(models.PointOfInterest.categories) # Eager load categories
    ).filter(models.PointOfInterest.id == poi_id).first()

def get_pois(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.PointOfInterest).options(
        joinedload(models.PointOfInterest.location)
    ).offset(skip).limit(limit).all()

def get_poi_by_slug(db: Session, slug: str):
    return db.query(models.PointOfInterest).filter(models.PointOfInterest.slug == slug).first()

def create_poi(db: Session, poi: schemas.PointOfInterestCreate):
    # Check if slug already exists
    if get_poi_by_slug(db, poi.slug):
        raise HTTPException(status_code=400, detail=f"POI with slug '{poi.slug}' already exists.")

    # Create Location
    db_location = models.Location(**poi.location.model_dump())
    # GeoAlchemy2 expects WKT format for point
    db_location.coordinates = f'POINT({poi.location.coordinates.coordinates[0]} {poi.location.coordinates.coordinates[1]})'
    
    # Create base POI
    poi_data = poi.model_dump(exclude={'location', 'business', 'outdoors', 'event', 'category_ids'}) # Exclude category_ids
    db_poi = models.PointOfInterest(**poi_data)
    db_poi.location = db_location

    # Handle categories
    if poi.category_ids:
        for cat_id in poi.category_ids:
            # Use the directly imported function
            category = get_category(db, cat_id)
            if category:
                db_poi.categories.append(category)

    # Create subtype based on poi_type
    if poi.poi_type == 'business' and poi.business:
        db_business = models.Business(**poi.business.model_dump())
        db_poi.business = db_business
    elif poi.poi_type == 'outdoors' and poi.outdoors:
        db_outdoors = models.Outdoors(**poi.outdoors.model_dump())
        db_poi.outdoors = db_outdoors
    elif poi.poi_type == 'event' and poi.event:
        db_event = models.Event(**poi.event.model_dump())
        db_poi.event = db_event

    try:
        db.add(db_poi)
        db.commit()
        db.refresh(db_poi)
    except IntegrityError as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Database integrity error: {e.orig}")
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

    return db_poi

def delete_poi(db: Session, poi_id: uuid.UUID):
    db_poi = get_poi(db, poi_id)
    if not db_poi:
        return None
    db.delete(db_poi)
    db.commit()
    return db_poi
</file>

<file path="backend/app/database.py">
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .core.config import settings

engine = create_engine(settings.DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="backend/app/main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.api.endpoints import pois, categories # Import categories
from app.database import engine, Base

# This line can be used to create tables if not using Alembic,
# but with Alembic it's better to manage schema via migrations.
# Base.metadata.create_all(bind=engine)

app = FastAPI(title="Nearby Nearby API")

# Set up CORS
origins = [
    "http://localhost",
    "http://localhost:5173", # Default Vite dev server port
    "https://nearbynearby.tesslate.com"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(pois.router, prefix="/api", tags=["Points of Interest"])
app.include_router(categories.router, prefix="/api/categories", tags=["Categories"]) # Add category router

@app.get("/")
def read_root():
    return {"message": "Nearby Nearby API"}
</file>

<file path="backend/app/models/__init__.py">
# This file makes it possible to import models like:
# from app.models import PointOfInterest
# instead of the more verbose:
# from app.models.poi import PointOfInterest

from .poi import PointOfInterest, Location, Business, Outdoors, Event
from .category import Category, poi_category_association
</file>

<file path="backend/app/models/poi.py">
import uuid
from sqlalchemy import Column, String, Text, ForeignKey, Numeric, TIMESTAMP
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from geoalchemy2 import Geometry

from app.database import Base
from app.models.category import poi_category_association # Import the association table

# Note: For the MVP, we are focusing on the POI-related models.
# The `users` and `categories` tables from the schema can be implemented here
# in a similar fashion when they are needed.

class Location(Base):
    __tablename__ = "locations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    address_line1 = Column(String)
    city = Column(String)
    state_abbr = Column(String(2))
    postal_code = Column(String)
    coordinates = Column(Geometry(geometry_type='POINT', srid=4326), nullable=False)

class PointOfInterest(Base):
    __tablename__ = "points_of_interest"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    slug = Column(String, unique=True, nullable=False, index=True)
    description = Column(Text)
    poi_type = Column(String, nullable=False) # 'business', 'park', 'trail', 'event'
    status = Column(String, nullable=False, default='active')
    
    location_id = Column(UUID(as_uuid=True), ForeignKey("locations.id"))
    
    location = relationship("Location")

    # Relationships to subtypes (one-to-one)
    business = relationship("Business", back_populates="poi", uselist=False, cascade="all, delete-orphan")
    outdoors = relationship("Outdoors", back_populates="poi", uselist=False, cascade="all, delete-orphan")
    
    # FIX: Specify the foreign key to resolve ambiguity.
    # This relationship describes the case where the POI *is* an Event.
    event = relationship(
        "Event",
        back_populates="poi",
        foreign_keys="Event.poi_id",
        uselist=False,
        cascade="all, delete-orphan"
    )

    # For completeness, define the other side of the venue relationship.
    # A POI can be a venue for many events.
    hosted_events = relationship("Event", back_populates="venue", foreign_keys="Event.venue_poi_id")

    # NEW: Many-to-many relationship with Category
    categories = relationship(
        "Category",
        secondary=poi_category_association,
        backref="pois" # Use backref here for simplicity on the other side
    )


class Business(Base):
    __tablename__ = "businesses"
    
    poi_id = Column(UUID(as_uuid=True), ForeignKey("points_of_interest.id"), primary_key=True)
    price_range = Column(String)
    amenities = Column(JSONB)
    
    # NEW: Listing type for Free vs Paid
    listing_type = Column(String, nullable=False, default='free') # Can be 'free' or 'paid'
    
    # NEW: Flexible attributes for granular data like food types, beer types, etc.
    attributes = Column(JSONB)

    poi = relationship("PointOfInterest", back_populates="business")

class Outdoors(Base):
    __tablename__ = "outdoors"

    poi_id = Column(UUID(as_uuid=True), ForeignKey("points_of_interest.id"), primary_key=True)
    outdoor_specific_type = Column(String) # 'park', 'trail'
    facilities = Column(JSONB)
    trail_length_km = Column(Numeric(6, 2))
    
    poi = relationship("PointOfInterest", back_populates="outdoors")

class Event(Base):
    __tablename__ = "events"

    # Foreign key for when the POI *is* an event
    poi_id = Column(UUID(as_uuid=True), ForeignKey("points_of_interest.id"), primary_key=True)
    start_datetime = Column(TIMESTAMP(timezone=True), nullable=False)
    end_datetime = Column(TIMESTAMP(timezone=True))
    
    # Foreign key for the POI that is the event's *venue*
    venue_poi_id = Column(UUID(as_uuid=True), ForeignKey("points_of_interest.id"))
    
    # FIX: Specify the foreign key to resolve ambiguity.
    poi = relationship(
        "PointOfInterest",
        back_populates="event",
        foreign_keys=[poi_id]
    )

    # For completeness, define the relationship to the venue POI.
    venue = relationship(
        "PointOfInterest",
        back_populates="hosted_events",
        foreign_keys=[venue_poi_id]
    )
</file>

<file path="backend/app/schemas/__init__.py">
# This file makes it possible to import schemas like:
# from app.schemas import PointOfInterest
# instead of the more verbose:
# from app.schemas.poi import PointOfInterest

from .poi import PointOfInterest, PointOfInterestCreate, PointOfInterestUpdate, Location, LocationCreate
# FIX: Add the new category schemas to the package's namespace
from .category import Category, CategoryCreate, CategoryWithChildren
</file>

<file path="backend/app/schemas/poi.py">
import uuid
import re
from datetime import datetime
from typing import Optional, List, Any

from pydantic import BaseModel, field_validator, model_validator
# FIX: Import tools to handle GeoAlchemy2's WKBElement
from geoalchemy2.elements import WKBElement
from geoalchemy2.shape import to_shape

# Import the new category schema to be used in POI schema
from .category import Category

# Helper for slug generation
def generate_slug(value: str) -> str:
    s = value.lower().strip()
    s = re.sub(r'[^\w\s-]', '', s)
    s = re.sub(r'[\s_-]+', '-', s)
    s = re.sub(r'^-+|-+$', '', s)
    return s

# GeoJSON-like structure for coordinates
class PointGeometry(BaseModel):
    type: str = "Point"
    coordinates: List[float]

    @field_validator('coordinates')
    def validate_coordinates(cls, v):
        if len(v) != 2:
            raise ValueError('Coordinates must be a list of two floats [longitude, latitude]')
        return v

    # FIX: Add a validator to handle the WKBElement from the database
    @model_validator(mode='before')
    @classmethod
    def parse_wkb(cls, v):
        if isinstance(v, WKBElement):
            # Convert WKBElement to a shapely geometry, then extract coordinates
            point = to_shape(v)
            return {"type": "Point", "coordinates": list(point.coords)[0]}
        # If it's already a dict (from a POST request), pass it through
        return v

# Location Schemas
class LocationBase(BaseModel):
    address_line1: Optional[str] = None
    city: Optional[str] = None
    state_abbr: Optional[str] = None
    postal_code: Optional[str] = None
    coordinates: PointGeometry

class LocationCreate(LocationBase):
    pass

class Location(LocationBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

# Business Schemas
class BusinessBase(BaseModel):
    price_range: Optional[str] = None
    amenities: Optional[Any] = None
    listing_type: str = 'free' # NEW
    attributes: Optional[dict] = None # NEW

class BusinessCreate(BusinessBase):
    pass

class Business(BusinessBase):
    poi_id: uuid.UUID

    class Config:
        from_attributes = True

# Outdoors Schemas
class OutdoorsBase(BaseModel):
    outdoor_specific_type: Optional[str] = None
    facilities: Optional[Any] = None
    trail_length_km: Optional[float] = None

class OutdoorsCreate(OutdoorsBase):
    pass

class Outdoors(OutdoorsBase):
    poi_id: uuid.UUID

    class Config:
        from_attributes = True

# Event Schemas
class EventBase(BaseModel):
    start_datetime: datetime
    end_datetime: Optional[datetime] = None

class EventCreate(EventBase):
    pass

class Event(EventBase):
    poi_id: uuid.UUID

    class Config:
        from_attributes = True

# Point of Interest Schemas
class PointOfInterestBase(BaseModel):
    name: str
    description: Optional[str] = None
    poi_type: str
    status: str = 'active'

    @field_validator('poi_type')
    def poi_type_must_be_valid(cls, v):
        if v not in ['business', 'outdoors', 'event']:
            raise ValueError("poi_type must be 'business', 'outdoors', or 'event'")
        return v

class PointOfInterestCreate(PointOfInterestBase):
    slug: Optional[str] = None
    location: LocationCreate
    business: Optional[BusinessCreate] = None
    outdoors: Optional[OutdoorsCreate] = None
    event: Optional[EventCreate] = None
    category_ids: Optional[List[uuid.UUID]] = [] # NEW

    @model_validator(mode='before')
    @classmethod
    def generate_slug_from_name(cls, values):
        if isinstance(values, dict):
             if not values.get('slug') and values.get('name'):
                values['slug'] = generate_slug(values['name'])
        return values

class PointOfInterestUpdate(PointOfInterestBase):
    name: Optional[str] = None
    poi_type: Optional[str] = None
    location: Optional[LocationCreate] = None
    business: Optional[BusinessCreate] = None
    outdoors: Optional[OutdoorsCreate] = None
    event: Optional[EventCreate] = None


class PointOfInterest(PointOfInterestBase):
    id: uuid.UUID
    slug: str
    location: Location
    business: Optional[Business] = None
    outdoors: Optional[Outdoors] = None
    event: Optional[Event] = None
    categories: List[Category] = [] # NEW
    
    class Config:
        from_attributes = True
</file>

<file path="backend/Dockerfile">
# Stage 1: Build stage
FROM python:3.10-slim as builder

WORKDIR /app

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Install build dependencies
RUN pip install --upgrade pip

# Copy and install requirements
COPY requirements.txt .
RUN pip wheel --no-cache-dir --wheel-dir /app/wheels -r requirements.txt


# Stage 2: Final stage
FROM python:3.10-slim

WORKDIR /app

# Copy built wheels from the builder stage
COPY --from=builder /app/wheels /wheels

# Install dependencies from wheels
RUN pip install --no-cache /wheels/*

# Copy application code
COPY . .

# Run uvicorn server
# The host 0.0.0.0 is important to make the server accessible from outside the container
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
</file>

<file path="backend/requirements.txt">
fastapi
uvicorn[standard]
sqlalchemy
psycopg2-binary
pydantic[email]
pydantic-settings
alembic
python-dotenv
# FIX: Include the optional shapely dependency
GeoAlchemy2[shapely]

# Test dependencies
pytest
httpx
</file>

<file path="backend/tests/conftest.py">
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os
import sys

# Add the project root to the Python path so 'app' can be imported.
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app.main import app
from app.database import Base, get_db
from app.core.config import settings

# Use the database URL from the environment, which will be set by docker-compose
engine = create_engine(settings.DATABASE_URL)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture(scope="function")
def db_session():
    """
    Fixture to create all tables for a test, and drop them after.
    This ensures every test gets a clean database.
    """
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)


@pytest.fixture(scope="function")
def client(db_session):
    """
    Fixture to create a test client that uses the clean database session.
    """
    def override_get_db():
        try:
            yield db_session
        finally:
            db_session.close()

    app.dependency_overrides[get_db] = override_get_db
    
    with TestClient(app) as c:
        yield c
        
    app.dependency_overrides.clear()
</file>

<file path="backend/tests/test_pois_api.py">
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

# Note: No need to import from app directly, fixtures handle it.

def test_create_and_read_poi(client: TestClient, db_session: Session):
    """
    Tests creating a POI and then retrieving it to ensure correctness.
    """
    # 1. Create a "business" type POI
    business_payload = {
        "name": "Test Cafe",
        "description": "A cozy place for coffee.",
        "poi_type": "business",
        "location": {
            "address_line1": "123 Test St",
            "city": "Testville",
            "state_abbr": "TS",
            "postal_code": "12345",
            "coordinates": {"type": "Point", "coordinates": [-75.4, 35.9]}
        },
        "business": {
            "price_range": "$$"
        }
    }
    
    response = client.post("/api/pois/", json=business_payload)
    
    # Assertions for the creation
    assert response.status_code == 201, response.text
    data = response.json()
    assert data["name"] == business_payload["name"]
    assert data["poi_type"] == "business"
    assert data["business"]["price_range"] == "$$"
    assert "id" in data
    assert "slug" in data and data["slug"] == "test-cafe"
    poi_id = data["id"]

    # 2. Read the created POI by its ID
    response = client.get(f"/api/pois/{poi_id}")
    
    # Assertions for reading the specific POI
    assert response.status_code == 200, response.text
    data = response.json()
    assert data["name"] == "Test Cafe"
    assert data["location"]["city"] == "Testville"
    assert data["location"]["coordinates"]["coordinates"] == [-75.4, 35.9]

def test_read_pois_list(client: TestClient, db_session: Session):
    """
    Tests retrieving a list of all POIs.
    """
    # Create a POI first
    client.post("/api/pois/", json={
        "name": "Another Test POI",
        "poi_type": "outdoors",
        "location": { "coordinates": {"type": "Point", "coordinates": [-76, 36]} },
        "outdoors": { "outdoor_specific_type": "park" }
    })

    response = client.get("/api/pois/")
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    assert len(data) > 0
    assert data[0]["name"] == "Another Test POI"

def test_delete_poi(client: TestClient, db_session: Session):
    """
    Tests creating a POI and then deleting it.
    """
    # 1. Create a POI to delete
    poi_payload = {
        "name": "To Be Deleted",
        "poi_type": "event",
        "location": { "coordinates": {"type": "Point", "coordinates": [-77, 37]} },
        "event": { "start_datetime": "2025-12-25T18:00:00Z" }
    }
    create_response = client.post("/api/pois/", json=poi_payload)
    assert create_response.status_code == 201
    poi_id = create_response.json()["id"]

    # 2. Delete the POI
    delete_response = client.delete(f"/api/pois/{poi_id}")
    assert delete_response.status_code == 200
    assert delete_response.json()["name"] == "To Be Deleted"

    # 3. Verify it's gone
    get_response = client.get(f"/api/pois/{poi_id}")
    assert get_response.status_code == 404


def test_create_poi_with_existing_slug(client: TestClient, db_session: Session):
    """
    Tests that creating a POI with a slug that already exists fails.
    """
    poi_payload = {
        "name": "Unique Name",
        "poi_type": "business",
        "location": { "coordinates": {"type": "Point", "coordinates": [-78, 38]} },
        "business": {}
    }
    
    # Create it the first time - should succeed
    response1 = client.post("/api/pois/", json=poi_payload)
    assert response1.status_code == 201

    # Try to create it again with the same name/slug - should fail
    response2 = client.post("/api/pois/", json=poi_payload)
    assert response2.status_code == 400
    assert "already exists" in response2.json()["detail"]
</file>

<file path="docker-compose.yml">
version: "3.8"

services:
  # --- DEVELOPMENT SERVICES ---
  db:
    image: postgis/postgis:15-3.4
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=nearby
      - POSTGRES_PASSWORD=nearby
      - POSTGRES_DB=nearbynearby
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U nearby -d nearbynearby"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    command: sh -c "alembic upgrade head && uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload"
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app
    environment:
      - DATABASE_URL=postgresql://nearby:nearby@db/nearbynearby
    depends_on:
      db:
        condition: service_healthy

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    volumes:
      - ./frontend:/app
      - /app/node_modules
    ports:
      - "5173:5173"
    environment:
      - VITE_API_BASE_URL=https://apin.tesslate.com
    depends_on:
      - backend

  # --- TESTING SERVICES ---
  test-db:
    image: postgis/postgis:15-3.4
    environment:
      - POSTGRES_USER=testuser
      - POSTGRES_PASSWORD=testpassword
      - POSTGRES_DB=testdb
    # No ports or volumes needed, it's only for internal use

  test:
    build: ./backend
    command: ["pytest"]
    volumes:
      - ./backend:/app
    environment:
      - DATABASE_URL=postgresql://testuser:testpassword@test-db/testdb
      - TESTING=True
    depends_on:
      - test-db

volumes:
  postgres_data:
</file>

<file path="file_populator.py">
import os
import re
import sys

def create_project_from_spec(file_path):
    """
    Parses a file containing <file> tags and creates the specified
    directory structure and files.
    """
    print(f"Reading project specification from: {file_path}")
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"ERROR: The file '{file_path}' was not found.")
        print("Please save the <files> block into a file named 'files.txt' in the same directory as this script.")
        sys.exit(1)

    # Regex to find each <file> tag and its content
    # re.DOTALL makes . match newlines
    file_pattern = re.compile(r'<file path="(.*?)">(.*?)</file>', re.DOTALL)
    
    # Regex to find the code within ```...``` blocks, ignoring the language specifier
    code_pattern = re.compile(r'```[a-zA-Z]*\n(.*?)\n```', re.DOTALL)

    files_created = 0
    
    # Find all file blocks in the text
    file_matches = file_pattern.finditer(content)

    for file_match in file_matches:
        relative_path = file_match.group(1).strip()
        inner_content = file_match.group(2)

        # Extract the code from the ``` block
        code_match = code_pattern.search(inner_content)
        
        if not code_match:
            print(f"  - WARNING: Could not find a ```code``` block in {relative_path}. Skipping.")
            continue

        code_to_write = code_match.group(1)

        try:
            # Get the directory part of the path
            directory = os.path.dirname(relative_path)
            
            # Create the directory structure if it doesn't exist
            if directory:
                os.makedirs(directory, exist_ok=True)
                print(f"  - Directory '{directory}' created or already exists.")

            # Write the extracted code to the file
            with open(relative_path, 'w', encoding='utf-8') as f:
                f.write(code_to_write)
            
            print(f"  - SUCCESS: Created file '{relative_path}'")
            files_created += 1
            
        except IOError as e:
            print(f"  - ERROR: Could not write file '{relative_path}'. Reason: {e}")
        except Exception as e:
            print(f"  - ERROR: An unexpected error occurred for '{relative_path}'. Reason: {e}")

    print("\n-------------------------------------------------")
    if files_created > 0:
        print(f"Project creation complete. {files_created} files were created.")
        print("Next steps:")
        print("1. Navigate to the 'nearby-nearby-admin' directory: cd nearby-nearby-admin")
        print("2. Create a '.env.local' file from '.env' and set your ADMIN_PASSWORD.")
        print("3. Install dependencies: npm install")
        print("4. Run the development environment: docker-compose up --build")
    else:
        print("No files were created. Please check the format of 'files.txt'.")
    print("-------------------------------------------------")


if __name__ == "__main__":
    # The name of the file containing the project specification
    spec_file = "files.txt"
    create_project_from_spec(spec_file)
</file>

<file path="frontend/.eslintrc.cjs">
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react/jsx-runtime',
    'plugin:react-hooks/recommended',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parserOptions: { ecmaVersion: 'latest', sourceType: 'module' },
  settings: { react: { version: '18.2' } },
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    'react/prop-types': 'off'
  },
}
</file>

<file path="frontend/.gitignore">
node_modules/
</file>

<file path="frontend/Dockerfile">
# Use a Node.js base image suitable for development
FROM node:18-alpine

# Set the working directory inside the container
WORKDIR /app

# Copy package.json and package-lock.json (or yarn.lock, etc.) first
# to leverage Docker layer caching
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of your application code into the container
COPY . .

# The Vite dev server needs to be exposed on port 5173
EXPOSE 5173

# The command to start the Vite development server
# The `--host` flag is crucial to make the server accessible from outside the container
CMD ["npm", "run", "dev"]
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nearby Nearby Admin</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/nginx.conf">
server {
  listen 80;
  server_name localhost;

  root /usr/share/nginx/html;
  index index.html;

  location / {
    try_files $uri /index.html;
  }
}
</file>

<file path="frontend/package.json">
{
  "name": "nearby-nearby-admin",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@mantine/core": "^7.8.0",
    "@mantine/dates": "^7.8.0",
    "@mantine/form": "^7.8.0",
    "@mantine/hooks": "^7.8.0",
    "@mantine/notifications": "^7.8.0",
    "@tabler/icons-react": "^3.34.0",
    "axios": "^1.6.8",
    "dayjs": "^1.11.10",
    "leaflet": "^1.9.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-leaflet": "^4.2.1",
    "react-router-dom": "^6.22.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "postcss": "^8.4.38",
    "postcss-preset-mantine": "^1.15.0",
    "postcss-simple-vars": "^7.0.1",
    "vite": "^6.3.5"
  }
}
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="252.678" y1="253.276" x2="2.618" y2="3.216" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#41D1FF"/><stop offset="1" stop-color="#BD34FE"/></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="252.678" y1="253.276" x2="2.618" y2="3.216" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#FFEA83"/><stop offset="0.083" stop-color="#FFDD35"/><stop offset="1" stop-color="#FFA800"/></linearGradient></defs><path d="M255.153 166.387c-2.724 35.843-20.395 68.96-49.52 90.873c-29.124 21.912-65.482 31.912-101.41 26.387c-35.928-5.525-67.653-26.69-89.248-57.92C.84 195.34-5.27 155.852 4.418 118.33c9.688-37.522 35.844-68.63 72.884-86.29C114.342 14.38 156.458 4.23 195.42 10.337c38.962 6.107 72.58 28.51 94.61 62.133c22.03 33.622 30.22 75.488 25.123 115.936l-.16.14z" fill="url(#IconifyId1813088fe1fbc01fb466)"/><path d="M185.12 1.48C142.23-3.613 98.53 9.49 66.86 36.88C35.19 64.27 17.06 102.6 17.52 143.19c.46 40.59 20.38 78.53 50.82 102.2c30.44 23.67 70.52 32.83 109.81 25.04c39.29-7.79 71.16-32.32 89.2-66.07c18.04-33.75 21.2-74.07 9.17-111.43c-12.03-37.36-40.45-66.5-77.41-79.45z" fill="url(#IconifyId1813088fe1fbc01fb467)"/><path d="M185.12 1.48L121.97 97.4l34.42 1.48l-38.8 84.89l96.1-118.23c-9.2-11.58-19.8-21.8-31.28-30.22c-11.47-8.43-24.1-14.88-37.29-19.34z" fill="#fff"/></svg>
</file>

<file path="frontend/src/animations.css">
/* src/animations.css */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.fade-in {
  animation: fadeIn 0.5s ease-out forwards;
}

/* The flowy, animated background inspired by trees and hills */
.background-decoration {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 150px;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="%23F3E5F5" fill-opacity="1" d="M0,192L48,176C96,160,192,128,288,133.3C384,139,480,181,576,186.7C672,192,768,160,864,133.3C960,107,1056,85,1152,96C1248,107,1344,149,1392,170.7L1440,192L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path><path fill="%23E1BEE7" fill-opacity="0.8" d="M0,256L48,245.3C96,235,192,213,288,202.7C384,192,480,192,576,208C672,224,768,256,864,261.3C960,267,1056,245,1152,224C1248,203,1344,181,1392,170.7L1440,160L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path></svg>');
  background-repeat: no-repeat;
  background-size: cover;
  background-position: bottom;
  z-index: 0;
  pointer-events: none;
  opacity: 0.9;
}
</file>

<file path="frontend/src/App.jsx">
import { AppShell, Burger, Group, Title, NavLink } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { Routes, Route, Link } from 'react-router-dom';
import POIList from './components/POIList';
import POIForm from './components/POIForm';
import POIMap from './components/POIMap';
import CategoryList from './components/CategoryList'; // Import new component
import CategoryForm from './components/CategoryForm'; // Import new component

function App() {
  const [opened, { toggle }] = useDisclosure();

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md">
          <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
          <Title order={3} component={Link} to="/" style={{ textDecoration: 'none', color: 'inherit' }}>
            Nearby Nearby Admin
          </Title>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
        <NavLink label="Points of Interest" component={Link} to="/" />
        <NavLink label="POI Map" component={Link} to="/map" />
        <NavLink label="Manage Categories" component={Link} to="/categories" />
        <NavLink label="Create New POI" component={Link} to="/poi/new" />
      </AppShell.Navbar>

      <AppShell.Main>
        <Routes>
          <Route path="/" element={<POIList />} />
          <Route path="/map" element={<POIMap />} />
          <Route path="/poi/new" element={<POIForm />} />
          <Route path="/poi/:id/edit" element={<POIForm />} />
          <Route path="/categories" element={<CategoryList />} />
          <Route path="/category/new" element={<CategoryForm />} />
          <Route path="/category/:id/edit" element={<CategoryForm />} />
        </Routes>
      </AppShell.Main>
    </AppShell>
  );
}

export default App;
</file>

<file path="frontend/src/components/POIForm.jsx">
import { useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useForm } from '@mantine/form';
import { TextInput, Button, Group, Box, Title, Select, Textarea, NumberInput, Paper, SimpleGrid, Divider, Text, Radio, Alert } from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import { IconInfoCircle } from '@tabler/icons-react';
import axios from 'axios';
import { notifications } from '@mantine/notifications';
import { MapContainer, TileLayer, Marker, useMap, useMapEvents } from 'react-leaflet';
import { CategorySelector } from './CategorySelector';

const API_URL = import.meta.env.VITE_API_BASE_URL;

// --- Map Component Logic ---
function ChangeView({ center, zoom }) {
  const map = useMap();
  useEffect(() => {
    map.setView(center, zoom);
  }, [center, zoom, map]);
  return null;
}
function DraggableMarker({ position, onPositionChange }) {
  const map = useMap();
  useMapEvents({
    click(e) {
      onPositionChange(e.latlng);
      map.flyTo(e.latlng, map.getZoom());
    },
  });
  const handleDragEnd = (event) => {
    const marker = event.target;
    if (marker != null) {
      onPositionChange(marker.getLatLng());
    }
  };
  return <Marker draggable={true} eventHandlers={{ dragend: handleDragEnd }} position={position} />;
}
// --- End Map Component Logic ---

function POIForm() {
  const { id } = useParams();
  const navigate = useNavigate();
  const isEditing = Boolean(id);

  const form = useForm({
    initialValues: {
      name: '', description: '', poi_type: 'business', status: 'active',
      address_line1: '', city: '', state_abbr: 'NC', postal_code: '',
      longitude: -79.17, latitude: 35.72,
      price_range: '', outdoor_specific_type: 'park',
      start_datetime: null, end_datetime: null,
      listing_type: 'free',
      category_ids: [],
    },
    validate: {
      name: (value) => (value.length < 2 ? 'Name must have at least 2 characters' : null),
      longitude: (value) => (value === null || value === undefined ? 'Longitude is required' : null),
      latitude: (value) => (value === null || value === undefined ? 'Latitude is required' : null),
      start_datetime: (value, values) => (values.poi_type === 'event' && !value ? 'Start date/time is required for events' : null),
    },
  });

  useEffect(() => {
    if (isEditing) {
      axios.get(`${API_URL}/api/pois/${id}`)
        .then(response => {
          const poi = response.data;
          form.setValues({
            name: poi.name || '',
            description: poi.description || '',
            poi_type: poi.poi_type || 'business',
            status: poi.status || 'active',
            address_line1: poi.location?.address_line1 || '',
            city: poi.location?.city || '',
            state_abbr: poi.location?.state_abbr || 'NC',
            postal_code: poi.location?.postal_code || '',
            longitude: poi.location?.coordinates?.coordinates[0] ?? -79.17,
            latitude: poi.location?.coordinates?.coordinates[1] ?? 35.72,
            price_range: poi.business?.price_range || '',
            listing_type: poi.business?.listing_type || 'free',
            category_ids: poi.categories?.map(c => c.id) || [],
            outdoor_specific_type: poi.outdoors?.outdoor_specific_type || 'park',
            start_datetime: poi.event?.start_datetime ? new Date(poi.event.start_datetime) : null,
            end_datetime: poi.event?.end_datetime ? new Date(poi.event.end_datetime) : null,
          });
        })
        .catch(error => {
          notifications.show({ title: 'Error', message: 'Failed to fetch POI data.', color: 'red' });
        });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id, isEditing]);

  const handleSubmit = async (values) => {
    const payload = {
      name: values.name, description: values.description, poi_type: values.poi_type,
      status: values.status,
      category_ids: values.poi_type === 'business' ? values.category_ids : [], // Only send categories for businesses
      location: {
        address_line1: values.address_line1, city: values.city, state_abbr: values.state_abbr,
        postal_code: values.postal_code,
        coordinates: { type: "Point", coordinates: [values.longitude, values.latitude] },
      },
    };
    if (values.poi_type === 'business') payload.business = { price_range: values.price_range, listing_type: values.listing_type };
    if (values.poi_type === 'outdoors') payload.outdoors = { outdoor_specific_type: values.outdoor_specific_type };
    if (values.poi_type === 'event') payload.event = { start_datetime: values.start_datetime?.toISOString(), end_datetime: values.end_datetime?.toISOString() };

    if (isEditing) {
      notifications.show({ title: 'Info', message: 'Editing is not fully implemented. Please delete and recreate.', color: 'blue' });
      return;
    }
    try {
      await axios.post(`${API_URL}/api/pois/`, payload);
      notifications.show({ title: 'Success!', message: `POI "${values.name}" created!`, color: 'green' });
      navigate('/');
    } catch (error) {
      const errorMessage = error.response?.data?.detail ? JSON.stringify(error.response.data.detail) : 'Failed to create POI.';
      notifications.show({ title: 'Submission Error', message: errorMessage, color: 'red', autoClose: 7000 });
      console.error("Submission error:", error.response?.data || error.message);
    }
  };
  
  const currentPosition = [form.values.latitude, form.values.longitude];
  const handlePositionChange = (latlng) => {
    form.setFieldValue('latitude', latlng.lat);
    form.setFieldValue('longitude', latlng.lng);
  };

  const currentPoiType = form.values.poi_type;

  return (
    <Paper maw={800} mx="auto">
      <Title order={2} c="deep-purple.7" mb="xl">
        {isEditing ? `Editing: ${form.values.name || 'POI'}` : 'Create New Point of Interest'}
      </Title>

      <form onSubmit={form.onSubmit(handleSubmit)}>
        <Divider my="lg" label={<Text fw={500} size="lg">Core Information</Text>} labelPosition="left" />
        <TextInput withAsterisk label="Name" placeholder="e.g., The Local Pizzeria" {...form.getInputProps('name')} />
        <Textarea label="Description" placeholder="A brief description of the place" {...form.getInputProps('description')} mt="md" minRows={3} />
        <Select label="POI Type" withAsterisk data={['business', 'outdoors', 'event']} {...form.getInputProps('poi_type')} mt="md" />

        {currentPoiType === 'business' && (
          <>
            <Box mt="md" p="md" bg="gray.0" style={{ borderRadius: 'var(--mantine-radius-md)' }}>
              <Text fw={500} size="lg" mb="sm">Business Details</Text>
              <Radio.Group label="Listing Type" withAsterisk {...form.getInputProps('listing_type')} mb="md">
                <Group mt="xs"><Radio value="free" label="Free" /><Radio value="paid" label="Paid" /></Group>
              </Radio.Group>
              
              <Select label="Price Range" placeholder="e.g., $$" data={['$', '$$', '$$$', '$$$$']} {...form.getInputProps('price_range')} />

              {form.values.listing_type === 'paid' && (
                  <Alert icon={<IconInfoCircle size="1rem" />} title="Paid Features" color="violet" mt="lg">
                      More fields for photo galleries, social media links, operating hours, etc., would appear here for paid listings.
                  </Alert>
              )}
            </Box>
            
            <Divider my="xl" label={<Text fw={500} size="lg">Categories</Text>} labelPosition="left" />
            <CategorySelector value={form.values.category_ids} onChange={(ids) => form.setFieldValue('category_ids', ids)} />
          </>
        )}
        {currentPoiType === 'outdoors' && (
          <Box mt="md" p="md" bg="gray.0" style={{ borderRadius: 'var(--mantine-radius-md)' }}>
            <Text fw={500} size="lg" mb="sm">Outdoors Details</Text>
            <Select label="Outdoor Specific Type" data={['park', 'trail']} {...form.getInputProps('outdoor_specific_type')} />
          </Box>
        )}
        {currentPoiType === 'event' && (
          <Box mt="md" p="md" bg="gray.0" style={{ borderRadius: 'var(--mantine-radius-md)' }}>
            <Text fw={500} size="lg" mb="sm">Event Details</Text>
            <SimpleGrid cols={{ base: 1, sm: 2 }}>
              <DateTimePicker withAsterisk valueFormat="MMM D, YYYY h:mm A" label="Start Time" {...form.getInputProps('start_datetime')} />
              <DateTimePicker valueFormat="MMM D, YYYY h:mm A" label="End Time" {...form.getInputProps('end_datetime')} />
            </SimpleGrid>
          </Box>
        )}

        <Divider my="xl" label={<Text fw={500} size="lg">Location</Text>} labelPosition="left" />
        <Text c="dimmed" size="sm" mb="xs">Click on the map or drag the marker to set the precise location.</Text>
        <Box style={{ height: '350px', width: '100%', borderRadius: 'var(--mantine-radius-md)', overflow: 'hidden', border: '1px solid var(--mantine-color-gray-3)' }} mb="md">
          <MapContainer center={currentPosition} zoom={13} style={{ height: '100%', width: '100%' }}>
            <ChangeView center={currentPosition} zoom={13} />
            <TileLayer attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
            <DraggableMarker position={currentPosition} onPositionChange={handlePositionChange} />
          </MapContainer>
        </Box>
        <SimpleGrid cols={{ base: 1, sm: 2 }} mt="md">
          <NumberInput withAsterisk label="Latitude" readOnly {...form.getInputProps('latitude')} precision={6} />
          <NumberInput withAsterisk label="Longitude" readOnly {...form.getInputProps('longitude')} precision={6} />
        </SimpleGrid>
        <SimpleGrid cols={{ base: 1, sm: 2 }} mt="md">
          <TextInput label="Address (Optional)" placeholder="123 Main St" {...form.getInputProps('address_line1')} />
          <TextInput label="City (Optional)" placeholder="Pittsboro" {...form.getInputProps('city')} />
        </SimpleGrid>
        <SimpleGrid cols={{ base: 1, sm: 2 }} mt="md">
          <TextInput label="State" placeholder="NC" {...form.getInputProps('state_abbr')} />
          <TextInput label="Postal Code" placeholder="27312" {...form.getInputProps('postal_code')} />
        </SimpleGrid>

        <Group justify="flex-end" mt="xl">
          <Button variant="default" onClick={() => navigate('/')}>Cancel</Button>
          <Button type="submit" size="md">
            {isEditing ? 'Update POI' : 'Create POI'}
          </Button>
        </Group>
      </form>
    </Paper>
  );
}

export default POIForm;
</file>

<file path="frontend/src/components/POIList.jsx">
import { useState, useEffect } from 'react';
import axios from 'axios';
import { Table, Button, Group, Title, Anchor, Text, Paper, ActionIcon, Tooltip } from '@mantine/core';
import { Link, useNavigate } from 'react-router-dom';
import { notifications } from '@mantine/notifications';
import { IconPencil, IconTrash, IconPlus } from '@tabler/icons-react';

const API_URL = import.meta.env.VITE_API_BASE_URL;

function POIList() {
  const [pois, setPois] = useState([]);
  const navigate = useNavigate();

  const fetchPois = async () => {
    try {
      const response = await axios.get(`${API_URL}/api/pois/`);
      setPois(response.data);
    } catch (error) {
      notifications.show({
        title: 'Error fetching data',
        message: 'Could not load points of interest.',
        color: 'red',
        autoClose: 5000,
      });
      console.error("Error fetching POIs:", error);
    }
  };

  useEffect(() => {
    fetchPois();
  }, []);

  const handleDelete = async (poiId) => {
    if (window.confirm('Are you sure you want to delete this POI?')) {
      try {
        await axios.delete(`${API_URL}/api/pois/${poiId}`);
        notifications.show({
          title: 'Success!',
          message: 'POI deleted successfully!',
          color: 'green',
        });
        fetchPois();
      } catch (error) {
        notifications.show({
          title: 'Error',
          message: 'Failed to delete POI.',
          color: 'red',
        });
        console.error("Error deleting POI:", error);
      }
    }
  };

  const rows = pois.map((poi) => (
    <Table.Tr key={poi.id} style={{ transition: 'background-color 0.2s' }}>
      <Table.Td>
        <Anchor component={Link} to={`/poi/${poi.id}/edit`} fw={500}>
            {poi.name}
        </Anchor>
      </Table.Td>
      <Table.Td>
        <Text size="sm" c="dimmed" tt="capitalize">{poi.poi_type}</Text>
      </Table.Td>
      <Table.Td>{poi.location?.city}</Table.Td>
      <Table.Td>
        <Group gap="xs" justify="flex-end">
          <Tooltip label="Edit POI">
            <ActionIcon variant="subtle" color="gray" onClick={() => navigate(`/poi/${poi.id}/edit`)}>
              <IconPencil size={18} />
            </ActionIcon>
          </Tooltip>
          <Tooltip label="Delete POI">
            <ActionIcon variant="subtle" color="red" onClick={() => handleDelete(poi.id)}>
              <IconTrash size={18} />
            </ActionIcon>
          </Tooltip>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <Paper>
      <Group justify="space-between" mb="lg">
        <Title order={2} c="deep-purple.7">Points of Interest</Title>
        <Button onClick={() => navigate('/poi/new')} leftSection={<IconPlus size={18} />}>
            Create New POI
        </Button>
      </Group>
      {pois.length > 0 ? (
        <Table striped highlightOnHover withTableBorder>
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Name</Table.Th>
              <Table.Th>Type</Table.Th>
              <Table.Th>City</Table.Th>
              <Table.Th style={{ textAlign: 'right' }}>Actions</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows}</Table.Tbody>
        </Table>
      ) : (
        <Text c="dimmed" ta="center" py="xl">
            No points of interest found. Create one to get started!
        </Text>
      )}
    </Paper>
  );
}

export default POIList;
</file>

<file path="frontend/src/components/POIMap.jsx">
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import { MapContainer, TileLayer, Marker, Popup } from 'react-leaflet';
import { Drawer, Title, Text, Button, Stack, Badge, Paper } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconPencil } from '@tabler/icons-react';
import L from 'leaflet';

const API_URL = import.meta.env.VITE_API_BASE_URL;

// Fix for default Leaflet icon path issue with bundlers like Vite
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
});

function POIMap() {
  const [pois, setPois] = useState([]);
  const [selectedPoi, setSelectedPoi] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchPois = async () => {
      try {
        const response = await axios.get(`${API_URL}/api/pois/?limit=1000`);
        setPois(response.data);
      } catch (error) {
        notifications.show({
          title: 'Error fetching data',
          message: 'Could not load points of interest for the map.',
          color: 'red',
        });
        console.error("Error fetching POIs for map:", error);
      }
    };
    fetchPois();
  }, []);

  const handleMarkerClick = (poi) => {
    setSelectedPoi(poi);
  };

  const handleEditClick = () => {
    if (selectedPoi) {
      navigate(`/poi/${selectedPoi.id}/edit`);
    }
  };

  const renderPoiDetails = () => {
    if (!selectedPoi) return null;
    
    const { name, description, poi_type, location, business, outdoors, event } = selectedPoi;

    return (
        <Stack>
            <Title order={3}>{name}</Title>
            <Badge tt="capitalize">{poi_type}</Badge>
            <Text c="dimmed">{description || 'No description available.'}</Text>
            
            {location && (
                <Text size="sm" mt="md">
                    {location.address_line1}<br />
                    {location.city}, {location.state_abbr} {location.postal_code}
                </Text>
            )}

            {poi_type === 'business' && business && (
                <Text size="sm" fw={500} mt="sm">Price: {business.price_range || 'N/A'}</Text>
            )}

            {poi_type === 'outdoors' && outdoors && (
                <Text size="sm" fw={500} mt="sm">Trail Length: {outdoors.trail_length_km} km</Text>
            )}

            {poi_type === 'event' && event && (
                 <Text size="sm" fw={500} mt="sm">
                    Starts: {new Date(event.start_datetime).toLocaleString()}
                </Text>
            )}

            <Button onClick={handleEditClick} leftSection={<IconPencil size={16} />} mt="xl">
                Edit POI
            </Button>
        </Stack>
    );
  };

  return (
    <>
      <Paper style={{ height: '85vh', width: '100%' }} withBorder radius="md" p={0} shadow="sm">
        <MapContainer 
          center={[35.7, -79.1]}
          zoom={9} 
          scrollWheelZoom={true} 
          style={{ height: "100%", width: "100%", borderRadius: 'var(--mantine-radius-md)' }}
        >
          <TileLayer
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
            url="https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png"
          />
          {pois.map(poi => {
            const coords = poi.location?.coordinates?.coordinates;
            if (!coords || coords.length !== 2) return null;
            const position = [coords[1], coords[0]]; 

            return (
              <Marker 
                key={poi.id} 
                position={position}
                eventHandlers={{
                  click: () => handleMarkerClick(poi),
                }}
              >
                  <Popup>{poi.name}</Popup>
              </Marker>
            );
          })}
        </MapContainer>
      </Paper>
      
      <Drawer
        opened={!!selectedPoi}
        onClose={() => setSelectedPoi(null)}
        title="POI Details" // FIX: Changed title from a component to a simple string
        position="right"
        padding="xl"
        size="lg"
        shadow="md"
      >
        {renderPoiDetails()}
      </Drawer>
    </>
  );
}

export default POIMap;
</file>

<file path="frontend/src/main.jsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import { MantineProvider, createTheme } from '@mantine/core';
import { Notifications } from '@mantine/notifications';
import { BrowserRouter } from 'react-router-dom';

// Import CSS files
import 'leaflet/dist/leaflet.css';
import '@mantine/core/styles.css';
import '@mantine/dates/styles.css';
import '@mantine/notifications/styles.css';
import './animations.css'; // Import our new animations

// Define the theme based on the "Nearby Nearby" site
const theme = createTheme({
  colors: {
    'deep-purple': [
      '#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0',
      '#8E24AA', '#5A2C6C', '#6A1B9A', '#4A148C',
    ],
    'brand-green': [
      '#E4F8F0', '#B4EAD7', '#86DDC4', '#58CFB1', '#34BE82', '#2BAA74',
      '#239566', '#1B8158', '#146D4A', '#0D583C',
    ],
  },
  
  primaryColor: 'deep-purple',
  primaryShade: 7,

  fontFamily: 'Poppins, sans-serif',
  headings: {
    fontFamily: 'Poppins, sans-serif',
    fontWeight: '600',
  },
  
  defaultRadius: 'md',

  components: {
    Button: {
      defaultProps: {
        color: 'brand-green.4',
      },
      styles: {
        root: {
          transition: 'transform 0.1s ease-in-out, background-color 0.2s ease',
          '&:hover': {
            transform: 'scale(1.02)',
          },
        },
      },
    },
    Paper: {
        defaultProps: {
            withBorder: true,
            shadow: 'sm',
            p: 'xl',
            radius: 'lg',
        },
        styles: {
            root: {
                position: 'relative',
                zIndex: 1,
            }
        }
    },
    NavLink: {
        styles: (theme) => ({
            root: {
                borderRadius: theme.radius.md,
                transition: 'background-color 0.2s ease, color 0.2s ease',
                '&[dataActive]': {
                    backgroundColor: theme.colors['deep-purple'][0],
                    color: theme.colors['deep-purple'][8],
                },
            },
            label: {
                fontWeight: 500,
            },
        }),
    },
    Table: {
        styles: (theme) => ({
            thead: {
                backgroundColor: theme.colors.gray[0],
            },
            th: {
                fontWeight: 600,
            }
        })
    }
  },
});

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <MantineProvider theme={theme}>
      <Notifications position="top-right" />
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </MantineProvider>
  </React.StrictMode>
);
</file>

<file path="frontend/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    host: true, // needed for the Docker Container port mapping to work
    strictPort: true,
    port: 5173,
    watch: {
      usePolling: true,
    },
    allowedHosts: [
      '.tesslate.com',
    ],
  },
})
</file>

<file path="README.md">
# Nearby Nearby MVP

This repository contains the complete source code for the "Nearby Nearby" Minimum Viable Product (MVP). It features a full-stack application for managing geospatial Points of Interest (POIs), built with a modern, containerized architecture.

## Key Technologies

-   **Backend:** FastAPI (Python)
-   **Frontend:** React (Vite) with Mantine UI components
-   **Database:** PostgreSQL with PostGIS extension for geographic data
-   **ORM:** SQLAlchemy with GeoAlchemy2
-   **Containerization:** Docker & Docker Compose
-   **Database Migrations:** Alembic
-   **Testing:** Pytest

## Architecture

The application is fully containerized using Docker Compose and is split into several services:

-   **`frontend`**: A React single-page application built with Vite that serves as the admin dashboard. It allows users to create, view, and delete POIs.
-   **`backend`**: A FastAPI application that provides a RESTful API for all POI operations. It handles business logic, data validation (Pydantic), and communication with the database.
-   **`db`**: The primary PostgreSQL database instance with the PostGIS extension enabled. It persists all application data for the development environment.
-   **`test` & `test-db`**: A completely separate and isolated set of containers used exclusively for running the automated test suite. This ensures that testing does not interfere with the development database.

## Prerequisites

Before you begin, ensure you have the following installed on your system:
*   [Docker](https://www.docker.com/get-started)
*   [Docker Compose](https://docs.docker.com/compose/install/) (usually included with Docker Desktop)

## Running the Development Environment

These instructions will start the frontend, backend, and development database.

1.  **Clone the repository** (if you haven't already):
    ```bash
    git clone <your-repository-url>
    cd nearby-nearby-mvp
    ```

2.  **Build and start all services:**
    Run the following command from the root of the project directory. The `--build` flag is only necessary the first time or after changing dependencies (like `requirements.txt`).
    ```bash
    docker-compose up --build
    ```

### What Happens Next?

-   Docker will build the images for the `frontend` and `backend` services.
-   The `db` container will start and initialize the PostgreSQL database.
-   The `backend` container will wait for the database to be healthy, then run any pending Alembic database migrations automatically, and finally start the Uvicorn web server.
-   The `frontend` container will start the Vite development server.

### Accessing the Services

Once all containers are running, you can access the different parts of the application:

-   **Admin Frontend:** Open your browser to [http://localhost:5173](http://localhost:5173)
-   **Backend API Docs:** Open your browser to [http://localhost:8000/docs](http://localhost:8000/docs). This is an interactive API documentation page (Swagger UI) where you can explore and test the API endpoints directly.

## Running the Automated Tests

The project includes a robust, isolated testing environment. Tests run against a separate, temporary PostGIS database to ensure they are reliable and do not affect your development data.

1.  **Ensure your Docker daemon is running.** (Your development containers can be running or stopped; it doesn't matter).

2.  **Execute the test suite:**
    From the project's root directory, run the following command in your terminal:
    ```bash
    docker-compose run --rm test
    ```
    This command spins up temporary `test` and `test-db` containers, runs `pytest` inside the `test` container, prints the output, and then automatically removes the containers.

3.  **Expected Output:**
    You should see a summary indicating that all tests have passed.
    ```
    ============================= test session starts ==============================
    ...
    tests/test_pois_api.py ....                                      [100%]
    ============================== 4 passed in ...s ===============================
    ```

## Database Migrations (Alembic)

The application uses Alembic to manage database schema changes. Migrations are run automatically when the `backend` service starts.

If you make changes to the SQLAlchemy models in `backend/app/models/`, you will need to generate a new migration file.

1.  **Ensure the development services are running** (`docker-compose up`).
2.  **Open a new terminal** and run the following command to generate a new migration script. Replace `"your_descriptive_message"` with a short summary of your changes.
    ```bash
    docker-compose exec backend alembic revision --autogenerate -m "your_descriptive_message"
    ```
3.  A new migration file will be created in `backend/alembic/versions/`. The next time you run `docker-compose up`, this migration will be applied automatically.
</file>

</files>
